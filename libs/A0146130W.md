# A0146130W
###### /src/main/java/seedu/gtd/logic/commands/EditCommand.java
``` java
 /**
  * Adds a task to the address book.
  */
 public class EditCommand extends Command {
 
     public static final String COMMAND_WORD = "edit";
 
     public static final String MESSAGE_USAGE = COMMAND_WORD + ":\n" 
             + "Edits the task identified by the index number used in the last task listing.\n\t"
             + "Parameters: [INDEX] (must be a positive integer) prefix/[NEW DETAIL]\n\t"
             + "Example: " + COMMAND_WORD
             + " 1 p/9";
 
     public static final String MESSAGE_EDIT_TASK_SUCCESS = "Task updated: %1$s";
     
     private int targetIndex;
     private String detailType;
     private String newDetail;
 
     public EditCommand(int targetIndex, String detailType, String newDetail) {
         this.targetIndex = targetIndex;
         this.detailType = detailType;
         this.newDetail = newDetail;
     }
     
 
     @Override
     public CommandResult execute() {

         UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

         if (lastShownList.size() < targetIndex) {
             indicateAttemptToExecuteIncorrectCommand();
             return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
         }
         
        ReadOnlyTask toEdit = lastShownList.get(targetIndex);
        Task taskToUpdate = new Task(toEdit);
        
		try {
	      taskToUpdate = updateTask(taskToUpdate, detailType, newDetail);
		} catch (IllegalValueException ive) {
			return new CommandResult(ive.getMessage());
		}

         assert model != null;
         try {
			model.editTask(targetIndex, taskToUpdate);
		} catch (TaskNotFoundException e) {
			assert false : "The target task cannot be missing";
		}
         return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToUpdate));

     }
     
     private Task updateTask(Task taskToUpdate, String detailType, String newDetail) throws IllegalValueException {
    	 taskToUpdate.edit(detailType, newDetail);
    	 return taskToUpdate;
     }
 
 }
```
###### /src/main/java/seedu/gtd/logic/commands/FindCommand.java
``` java
    private final String keywords;
    private final Set<String> keywordSet;

    public FindCommand(String keywords, Set<String> keywordSet) {
        this.keywords = keywords;
        this.keywordSet = keywordSet;
    }
    
    private String getMessageForTaskListShownSummaryIfExactPhraseNotFound(int displaySize) {
    	String task_tasks = (displaySize == 1) ? "task" : "tasks";
    	
    	String MESSAGE_IF_EXACT_PHRASE_NOT_FOUND = "The exact phrase '" + keywords + "' was not found. Listing " + displaySize + " " + task_tasks + " containing the keywords entered instead.";
    	return String.format(MESSAGE_IF_EXACT_PHRASE_NOT_FOUND);
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords, keywordSet);
        
        if(model.getFilteredTaskList().isEmpty()) {
        	model.updateFilteredTaskList(keywordSet);
        	if(!model.getFilteredTaskList().isEmpty()) return new CommandResult(getMessageForTaskListShownSummaryIfExactPhraseNotFound(model.getFilteredTaskList().size()));
        }        
        
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### /src/main/java/seedu/gtd/logic/Logic.java
``` java
/**
 * API of the Logic component
 */
public interface Logic {
    /**
     * Executes the command and returns the result.
     * @param commandText The command as entered by the user.
     * @return the result of the command execution.
     */
    CommandResult execute(String commandText);

    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFilteredTaskList();

}
```
###### /src/main/java/seedu/gtd/logic/parser/DateNaturalLanguageProcessor.java
``` java
public class DateNaturalLanguageProcessor implements NaturalLanguageProcessor {
	
	private static final com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser();
	
	@Override
	public String formatString(String naturalLanguageDate) {
		List<DateGroup> dateGroups = parser.parse(naturalLanguageDate);
		return refineDateGroupList(dateGroups);
	}
	
	/*Does not tolerate alternative dates*/
	private String refineDateGroupList(List<DateGroup> groups) {
	  if(groups.size() == 1) {
		  return formatDateToString(groups.get(0).getDates().get(0));
	  }
	  else return "";
	}
	
	private String formatDateToString(Date date) {
		Format formatter = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
		return formatter.format(date);
	}
}
```
###### /src/main/java/seedu/gtd/logic/parser/NaturalLanguageProcessor.java
``` java
public interface NaturalLanguageProcessor {
	
	/*Takes in a string written in natural language and formats it.*/
	String formatString(String s);
}
```
###### /src/main/java/seedu/gtd/logic/parser/Parser.java
``` java
    private String parseDueDate(String dueDateRaw) {
    	NaturalLanguageProcessor nlp = new DateNaturalLanguageProcessor();
    	return nlp.formatString(dueDateRaw);
    }
    
```
###### /src/main/java/seedu/gtd/logic/parser/Parser.java
``` java
    /**
     * Parses arguments in the context of the edit task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareEdit(String args) {
        
        final Matcher matcher = EDIT_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        
        Optional<Integer> index = Optional.of(Integer.parseInt(matcher.group("targetIndex")));
        String newDetail = matcher.group("newDetail");
        System.out.println(newDetail);
        String detailType = extractDetailType(newDetail); 
        
        if(detailType != "name") {
        	newDetail = newDetail.substring(2);
        }
        
        System.out.println(index.get() + " " +  detailType + " " + newDetail);
        
        return new EditCommand(
           (index.get() - 1),
           detailType,
           newDetail
        );
    }
    
    private String extractDetailType(String detailType) {
    	System.out.println(detailType.substring(0, 2));
    	switch(detailType.substring(0, 2)) {
    	case "d/": return "dueDate";
    	case "a/": return "address";
    	case "p/": return "priority";
    	default: return "name";
    	}
    }
    
```
###### /src/main/java/seedu/gtd/model/AddressBook.java
``` java
    /**
     * Edits a task in the address book.
     * Also checks the updated task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.TaskNotFoundException if the task was not found.
     */
    public void editTask(int index, Task t) throws UniqueTaskList.TaskNotFoundException {
        syncTagsWithMasterList(t);
        tasks.edit(index, t);
    }
    
```
###### /src/main/java/seedu/gtd/model/ModelManager.java
``` java
    @Override
    public synchronized void editTask(int targetIndex, Task task) throws TaskNotFoundException {
        addressBook.editTask(targetIndex, task);
        updateFilteredListToShowAll();
        indicateAddressBookChanged();
    }
    
```
###### /src/main/java/seedu/gtd/model/task/UniqueTaskList.java
``` java
    /**
     * Edits an equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public void edit(int targetIndex, Task toEdit) throws TaskNotFoundException {
        assert toEdit != null;
        if (invalidIndex(targetIndex)) {
            throw new TaskNotFoundException();
        }
        internalList.set(targetIndex, toEdit);
    }
    
    private boolean invalidIndex(int i) {
    	if(i < 0 || i >= internalList.size()) return true;
    	return false;
    }
    
```
